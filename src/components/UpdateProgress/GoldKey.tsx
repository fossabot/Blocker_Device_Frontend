/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/old_gold_key/scene.gltf -t 
Author: 3Dee (https://sketchfab.com/mellydeeis)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/old-gold-key-f5dc85be7a5041af8664c50959c89001
Title: Old Gold Key
*/

import { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { Html } from '@react-three/drei';

type GLTFResult = GLTF & {
  nodes: {
    ['Material-material']: THREE.Mesh
    Object_5: THREE.Mesh
  }
  materials: {
    Material: THREE.MeshPhysicalMaterial
    material_0: THREE.MeshStandardMaterial
  }
}

interface GoldKeyProps {
  scale?: number | [number, number, number];
  position?: [number, number, number];
  rotation?: [number, number, number];
}

export default function GoldKey({
  scale = 1.5, // 더 크게
  position = [0, 1.5, 0], // 씬 중앙에 띄움
  rotation = [0, 0, 0]
}: GoldKeyProps) {
  const { nodes, materials } = useGLTF('/old_gold_key/scene-transformed.glb') as GLTFResult;
  const groupRef = useRef<THREE.Group>(null);
  const [showNewKey, setShowNewKey] = useState(false);

  useEffect(() => {
    // 필요한 경우 메터리얼 속성 조정
    if (materials.Material) {
      materials.Material.metalness = 1.0;       // 더 금속적인 느낌
      materials.Material.roughness = 0.05;      // 더 반짝이는 표면
      materials.Material.emissive = new THREE.Color(0xFCD34D);
      materials.Material.emissiveIntensity = 1.0;  // 발광 효과 증가
      materials.Material.needsUpdate = true;
    }
    if (materials.material_0) {
      materials.material_0.metalness = 1.0;
      materials.material_0.roughness = 0.05;
      materials.material_0.emissive = new THREE.Color(0xFCD34D);
      materials.material_0.emissiveIntensity = 1.0;
      materials.material_0.needsUpdate = true;
    }

    // 애니메이션: 차량에서 키가 나와 두 번 점프 후 복호화 시도, 복호화 완료 시 새로운 키 등장
    let animationId: number;
    const startX = position[0];
    const startY = position[1];
    const startZ = position[2];
    const jumpHeight = 2.5;
    const jumpDistance = 2.5;
    const jump1End = 0.8;
    const jump2End = 1.6;
    const decryptStart = jump2End;
    const decryptEnd = 2.8;
    const newKeyAppear = 3.0;
    const targetX = startX + jumpDistance * 2;
    const targetY = startY;
    const targetZ = startZ;
    const startTime = Date.now();

    const animate = () => {
      const t = (Date.now() - startTime) / 1000;
      let x = startX, y = startY, z = startZ;
      let showKey = false;
      if (t < jump1End) {
        // 첫 점프
        const p = t / jump1End;
        x = startX + jumpDistance * p;
        y = startY + Math.sin(Math.PI * p) * jumpHeight;
      } else if (t < jump2End) {
        // 두번째 점프
        const p = (t - jump1End) / (jump2End - jump1End);
        x = startX + jumpDistance + jumpDistance * p;
        y = startY + Math.sin(Math.PI * p) * jumpHeight;
      } else if (t < decryptEnd) {
        // 복호화 시도(떨림 효과)
        const p = (t - decryptStart) / (decryptEnd - decryptStart);
        x = targetX;
        y = targetY + Math.abs(Math.sin(p * Math.PI * 8)) * 0.2;
      } else if (t < newKeyAppear) {
        // 복호화 완료 직후(키 사라짐)
        x = targetX;
        y = targetY;
      } else {
        // 새로운 키 등장
        showKey = true;
      }
      if (groupRef.current) {
        groupRef.current.visible = !showKey;
        groupRef.current.position.set(x, y, z);
      }
      setShowNewKey(showKey);
      animationId = requestAnimationFrame(animate);
    };
    animationId = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(animationId);
  }, [position]);

  // geometry/material이 정상적으로 로드되지 않을 때 fallback
  if (!nodes || !materials || !nodes['Material-material'] || !nodes.Object_5) {
    return <group position={position}><Html center style={{color: 'red'}}>GoldKey 모델 로드 실패</Html></group>;
  }
  
  return (
    <>
      <group 
        ref={groupRef}
        scale={typeof scale === 'number' ? [scale, scale, scale] : scale} 
        position={position} 
        rotation={rotation} 
        dispose={null}
      >
        <group rotation={[-Math.PI / 2, 0, 0]}>
          <mesh 
            geometry={nodes['Material-material'].geometry} 
            material={materials.Material} 
            rotation={[0, Math.PI / 2, 0]} 
            scale={1} // 부모 scale만 적용
          />
          <mesh 
            geometry={nodes.Object_5.geometry} 
            material={materials.material_0} 
            rotation={[0, Math.PI / 2, 0]} 
            scale={1} // 부모 scale만 적용
          />
        </group>
      </group>
      {/* 복호화 완료 후 등장하는 새로운 대칭키 */}
      <group
        visible={showNewKey}
        position={[position[0] + 2.5 * 2 + 1.5, position[1] + 2, position[2]]}
        scale={[1.2, 1.2, 1.2]}
      >
        <mesh>
          <sphereGeometry args={[0.5, 32, 32]} />
          <meshStandardMaterial color={0xFCD34D} emissive={0xFCD34D} emissiveIntensity={1.2} />
        </mesh>
      </group>
    </>
  );
}

useGLTF.preload('/old_gold_key/scene-transformed.glb');
